---
title:      关于前端优化
date:       2020-04-15
categories:
    - 知识整理
tags:
    - 前端
    - html5
    - css3
    - JavaScript
    - 优化
excerpt: 谈谈前端优化。
---

# 关于前端优化

## 前言

转眼间学期已经要过半了，虽然上网课上了小半学期，但是要学、要做的东西还是蛮多的，前三四周基本都在面试和准备面试中度过了，又因为在家里，感觉基本还是在半玩半学吧。终于有时间可以静下心来整理整理最近面试到的、学到的、做到的涉及的一些知识。今天先来谈谈关于前端优化的一些问题。

## 正文

关于这方面由于笔者实际上接触到的一些项目还是太少，所以关于优化还没有特别的感触，唯一知道的是网络请求肯定不能太多的...刚开始学写网页的时候一些请求太多就玩崩过，所以下面一些内容都是基于资料和他人的博客来进行整理的。

在笔者看来，首先明确为什么要优化？这里优化具体指的是性能优化，也就是在相同情况下，网页展示的速度尽可能地快，并且不容易崩溃，又由于网页的承载体是浏览器，所以要考虑的也就是令浏览器加载网页尽量地快。那在谈到如何具体优化之前，我们应该去了解浏览器加载网页的相关原理，这才可以往下寻找答案。

### 浏览器原理

我们先来明确，浏览器通过不同的协议获取各式各样的文件，比如ftp，http。我们这里讨论的主要是通过http(s)协议以及URI来获取html等网页文件。获取这些文件之后通过浏览器的渲染引擎展现出来。

浏览器在操作系统里也是一种应用程序，它本身的一些功能这里也当然不进行探讨（如通用的一些前进后退、书签功能）。下图展示了浏览器的一些主要组件，在这篇文章中我们只关注于上面比较靠近应用层的Rendering engine（渲染引擎）、NetWork网络和JavaScript Interpreter编译器。

![浏览器组件](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/layers.png)

于是我们就可以有一个初步的优化思路了，渲染时优化、网络请求上的优化、Js编译时的优化。

### 渲染原理与优化手段

首先要知道浏览器的渲染引擎是**单线程**的，几乎所有操作，除了网络操作，都是在单线程引擎上实现的，所以我们必须要小心浏览器会不会发生阻塞，也是性能优化的一个最重要的问题。那么自然网络操作就是并行执行的了。浏览器的主线程是事件循环。它是一个无限循环，永远处于接受处理状态，并等待事件（如布局和绘制事件）发生，并进行处理。

实际上不同内核的浏览器在渲染网页时会有一些不同，但是总体上还是一样的。

webkit内核（chrome、safari）的渲染流程：

![webkit](https://images2018.cnblogs.com/blog/1028513/201805/1028513-20180530154313816-1498972038.png)

gecko（firefox）渲染的主要流程：

![gecko](https://images2018.cnblogs.com/blog/1028513/201805/1028513-20180530154341813-2090367224.jpg)

可以看到两个流程图是十分相像的。总结一下就是浏览器通过http或https协议获取到html和css文件之后，分别渲染出DOM作为骨架，CSSDOM作为显示规则，之后将两个树通过互相之间的引用规则（标签名、id名、类名等）联系在一起，再通过渲染树渲染出来。

下面这个简单一点的流程图会更清晰一点：

![simple](https://pic002.cnblogs.com/images/2011/265173/2011110316263715.png)

对这个图稍加解释一下：第一步是从html获取到dom树，第二步则是获取到cssdom树后将其与dom树合并得到的一个render树，第三步就是根据这个render树对网页元素进行排版定位，也就是layout，最后一步再进行绘制（形状、颜色）。

如果加上JavaScript，就形成了一个完整的关键渲染路径。在生成render tree之前会先执行好js脚本。在浏览器中对于脚本也就是\<script>标签的解析是具有一个优先级的，解析器遇到这个标签时文档的解析将会停止，直到脚本执行完毕，即便脚本是网络资源。这也就解释了为何有些时候我们需要将引用的script标签放到body之后才会令网页正常显示，也因此我们要注意脚本的一个阻塞问题。当然了在HTML5中，我们现在可以把脚本标记为异步了。

![key render path](https://pic2.zhimg.com/80/v2-fb631e4b74f5ef2481be8bbe1fdd98a5_720w.jpg)

这里阐述一下render树和dom树的联系（如下图所示）。display为none的元素不会在render tree中也就是我们都知道的不会被渲染，而display:hidden则会在render tree中。

![render and dom](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image025.png)

由此我们也可以顺带出两个概念reflow回流与repaint重绘，对应上面最后的两步，回流就是改变元素的定位，重新进行位置计算，重绘只是改变形状颜色等样式，很明显如果在使用css3动画或者对dom进行一些操作时，导致位置改变也就是回流的操作会比重绘操作更花时间一点，其实这里我们就已经引出了优化的其中一点——尽量减少回流重绘，尤其是回流。

这里顺带一提的是，浏览器的布局layout和绘制paint其实都采用了全局和增量的机制，并且在进行回流重绘时浏览器会尽可能地使用缓存来减少计算。

回到代码上来看，在HTML中进行优化，思路主要是防止堵塞，令dom树尽量简单容易渲染：

1. 将script标签放到body之后
2. 尽量少使用table，iframe等标签，他们在渲染的时候会经历不止一次的遍历，速度更慢一些；
3. 核心css和js在代码量不大的情况下直接写到html里面。

在css中进行优化，思路主要是减少重绘、提高cssdom与dom的匹配率：

1. 提取公共类样式，以及多使用继承，这是最简单也最理所当然的，不仅减少了代码量更是优化了性能；
2. 尽量少使用嵌套标签；
3. 压缩css文件，这个用现在的构建工具如gulp之类的都能做到；
4. 尽量减少回流重绘（尤其是动画），如一个需要变化100次的元素，我们可以先设为hidden，变换完成之后再取消hidden，就只需要2次的重绘；
5. css选择器尽量选择class，且最好唯一，这样匹配率更高；
6. 尽量不要使用@import，网络请求会慢是当然的，并且外部样式文件会在加载完后才渲染，也十分的不美观。

### 网络请求原理与优化手段

浏览器的网络请求一般步骤如下：

1. 根据输入的URL进行http请求；
2. dns解析，获取一个解析报文（也就是服务器ip地址）；
3. 客户端将这个解析报文发送到服务器，至此经历了tcp三次握手，建立了连接；
4. 服务器再根据客户端一开始的请求进行处理并返回响应报文；
5. 客户端接收报文，浏览器进行渲染。

相同的，在一个网页内获取其他各种资源的时候也是需要经过类似流程，在这方面优化最直观的就是尽量减少网络请求，因为相对于浏览器内部的运行速度来说，网络请求实在慢太多了。除了直接减少http请求如资源压缩合并（雪碧图）和懒加载外，而从另一个角度切入，**缓存**则是我们减少请求的一个有力武器。下面将会从这两个角度展开：

#### 直接减少

1. css sprites、懒加载
2. css和js文件压缩
3. 异步加载js（上文有提到）
   这里稍微具体展开聊聊。这里具体方法分为两种：
   - 动态脚本加载：利用document.createElement('script'),将这个标签的src属性修改成我们需要的地址就行
   - script标签中的defer/async属性：这两个从功能上都可以让script异步加载而不需要上文说的直接把script放到body之后去，但实际上defer的效果与放到body后是一致的，异步加载等到html解析完之后才会执行，而async则是如果在html解析时就已加载完毕会马上执行，终端html的解析。直观一点的可以看下图：
![async & defer](https://pic4.zhimg.com/80/v2-16c30946f2066f4c0a7dbfcfe492526b_720w.jpg)

#### 缓存

这里先要了解到浏览器的缓存机制。浏览器的缓存分为两种：强缓存和协商缓存。直观理解就是强缓存通过http报文头的设置，令浏览器在获取资源时直接去拿本地的缓存，但如果缓存的时间超过了规定时长，这个缓存就会失效，需要重新向服务器请求；协商缓存则是能检查到有缓存但是不确定是否能启用，则发送请求到服务器验证这个缓存是否能够使用或者说是否更新了，虽然这里也提起了请求但相对于缓存的量来说肯定是小很多的。

而如何合理设置对应报文头来管理缓存，因为内容较多，具体的笔者打算另外写一篇博客整理这方面的知识，之后会把链接放上来。

但是说到缓存，我们除了浏览器自身的缓存以外，在第一次打开时我们也可以加速，那就是CDN(Content Delivery Network)，相信不少人在学习jQuery的时候就会见到什么阿里cdn，百度cdn，简单来说就是把资源缓存在离客户机更近的服务器里面，这样在获取资源时当然就起到了一个加速的效果。

另外浏览器的缓存中还有sessionStorage和cookies，至于这两个的区别也会在另一篇文章中细说。因为如果有cookies的话每次的请求都会带上cookies，也会减慢速度。

还有一个与缓存类似的手段：DNS预解析。实际上现代浏览器中多数会默认为文档中的a标签打开dns预解析，当然了强制打开只要在HTML的meta标签中加上对应属性即可：

```html
<meta http-equiv="x-dns-prefetch-control" content="on">
```

对这一部分总结一下：

1. 服务器端合理设置报文头从而可以使用缓存；
2. 使用cdn加速；
3. 减少cookies的大小或者直接改用session；
4. 打开dns预解析。

### JavaScript代码&编译性能优化

js是前端开发三者中最重要的语言，并且实际上这是个很大的话题，里面会有许多细节，我们在这里只做一些基本的粗略介绍，了解最基本的优化原则即可。

相同的，解决这个问题我们也要有一定的逻辑顺序：

1. **js语言特征**？是一种动态的解释型语言，与c，java等编译型语言都不同，是一边即时编译一边执行的，因此速度会比较慢；

2. **编译**？一般顺序是：词法分析→语法分析→语法树→字节码→JIT(Just-in-time)即时编译→本地执行代码（机器码）。而流行的V8引擎还将字节码这一步省了，速度会更快。（与编译型语言比较：词法分析->语法分析->语义检查->代码优化和字节生成）；

3. **执行**？这里其实包含了两个过程：预解析和正式执行。预编译就是常见的var和function的变量提升，只不过这个阶段var定义的变量尚未赋值，为undefined。正式执行就是按照从上到下的顺序执行了。

但是在正式执行中仍有许多细节部分，最重要的就是同步异步的部分了。

首先js在执行时是单线程的，我们在上面所说的按照顺序从上到下执行的其实是同步部分(sync)，而因为一些网络操作的时间会比较长，如果全部都使用同步操作，会造成阻塞，所以一些诸如网络请求，IO设备操作就会划分为异步任务(async)，它指的是引擎内部会有另一个**任务队列(task queue)**，当某个异步任务可以执行时它就会通知主线程，把这个任务加入到主线程中。

![task queue](https://upload-images.jianshu.io/upload_images/13387321-e11540e6640740e2.png?imageMogr2/auto-orient/strip|imageView2/2/w/578/format/webp)

如上图所示，同步任务都会被压入主线程的执行栈中，而异步任务我们都知道是会有一个回调函数的，实际上当异步执行有结果之后，任务队列里放的就是这个回调函数。当执行栈中的所有同步任务执行完毕之后，就会读取任务队列，可以执行的就会压入执行栈执行。

![event loop](https://upload-images.jianshu.io/upload_images/13387321-dc3f5ce8a3e81e37.png?imageMogr2/auto-orient/strip|imageView2/2/w/594/format/webp)

而对于另一种比较特别的异步任务**定时器**，作用是将回调任务推迟或者相隔一段时间执行，如果时间参数填为0，则表示将这个回调任务放到了任务队列的末尾，所以无论如何都会比同步任务要晚执行。并且需要注意的是，如果同步任务耗时太多，是没有办法保证回调函数一定会在规定时间之后马上执行的。

其实同步异步任务之下还有更加细的分级——宏任务和微任务，主要是对异步再进行细分(Promise)，这里不展开阐述。

但实际上笔者在做完上述对js的一些资料整理之后，貌似对如何具体优化还是云里雾里，后面总结的具体优化方法结合了笔者个人经验和网上一些博客资料，有可能逻辑关系并不是十分的紧凑...：

1. 尽量少使用全局变量（多使用let而不是var），上文提到的变量提升问题；
2. 简化代码，如判断语句可以多使用三元运算符来代替；
3. 尽量减少对DOM操作；
4. 尽量使用js本身的构造和内建函数，在JIT编译时可以省许多时间；
5. 尽量使用for循环而不是for...in循环；

## 总结

其实前端优化是个非常大的课题，以笔者十分浅薄的开发经历其实没什么办法完全把这个问题说的很好，不过在按照自己的思路去查找资料，解决问题的过程中其实已经可以大概有解决方案了：

分别针对html，css，javascript来优化，根据其渲染、编译原理，虽然各有不同的优化细节，但也有一些共通的优化方法——三者之间的解耦合，代码压缩，外部引用的抉择等。

最重要的其实还是针对浏览器本身加载页面原理上的性能优化——渲染和网络请求问题。
