---
title:      Typescript入门（二）
date:       2020-08-06
categories:
    - 知识整理
tags:
    - 前端
    - TypeScript
    - 入门
excerpt:  Typescript入门（二）
---
# TypeScript入门（二）
接着上一篇我们对ts类型的介绍，继续来看ts的一些特性。
## 类型断言
类型断言顾名思义就是在我们未知这个变量的类型时，我们手动给它断定一个类型，实际上就是“欺骗”编译器变量是我们指定的类型。但是如果使用确实出错了运行依然会出错。使用断言多数在于一些判断条件中，因为一些特有属性需要我们先对类型进行断言才能去使用。
语法上，我们使用```as```，如下所示：

```typescript
function isFish(animal: Cat | Fish) {
    if(typeof (animal as Fish).swim === 'function') {
        return true;
        }
    }
```

类型断言在父子类中也很常见，有点像instanceof函数，但是由于ts中新增的接口(interface)并不是一个类，所以类型断言as就可以代替instanceof使用在接口上。

还有关于最特别的任意类型any，任何类型都可以断言为any，any也可以被断言为任何类型。不过我们应该尽量不要使用any的断言，除非在自己十分确定的情况下，因为他会掩盖掉真正的类型错误。反过来，如果别人的代码里写了```as any```我们在使用的时候应该想办法明确返回值的类型并进行具体的断言。

因此综上所述，我们可以知道类型断言的首要前提是被断言的变量的类型包含了断言类型，比如子类的属性方法必然是包含了父类的属性方法的，我们在ts上也把这个称为“兼容”，也就是父类兼容子类。但是反过来看，子类里的一些属性在父类里面没有，所以子类并不兼容父类。

**也就是说只要一种类型“兼容”对方，在ts中就可以互相被断言。**

但同时我们也会发现断言貌似与定义类型十分相像，只是一个在定义阶段去断定，一个在使用阶段去断定。而除此以外，类型定义也更加严格，见如下代码：

```typescript
// Mouse是Animal的一个子类型
let animal: Animal = {  name: 'Jerry',}let jerry: Mouse = animal // 会报错
let mouse = {  name: 'jerry',  run: () => {    console.log('run')  }}let jerry2: Animal = mouse // 正常通过
```

也就是说我们在进行定义类型的时候，只有当A兼容B的时候，才能将A类型的变量定义成B类型，而不能把B类型的变量定义成A类型的，但是这在断言中却是双向的。这就是他们最主要的一个区别。

## 声明文件

这一部分主要是ts对文件引入/导出，模块化的一些新语法。在ts中，我们在引入模块的时候，还需要进行一个声明，告诉编译器引入的模块是什么，全局定义一个变量。语法大致如下：

```typescript
declare const jQuery: (selector: string) => any
// const 换成let/var/class/function/enum等也是一样的
// 定义interface前面不需要加declare
// 比较特别的还有namespace，它用来定义一个拥有多个子属性的对象，其实就是相当于给予一个独立的作用域（命名空间），防止命名冲突
// 用declare定义的多个同名是可以合并的，也就是说比如我把jQuery同时定义为namespace和function，在使用的时候都是可以起效的，称为声明合并
```

而ts中一般用一个后缀为.d.ts的文件来对模块声明进行管理，我们称之为**声明文件**。而ts编译器会识别到项目中所有带.ts后缀的文件，自然也就包含了.d.ts文件，如果无法识别应该去查tsconfig.json文件的配置是否出错。当然了，每次引用模块都需要我们自己手动写是十分麻烦的，我们在安装第三方模块的时候可以通过```npm install @types/jquery --save-dev```来安装别人写好的声明文件，多数流行的包作者当然也会顺带写上，我们也跟之前在js中调用一样直接调用就可以了。一般项目结构中用一个与src文件夹同级的type文件夹来统一管理声明文件。

### 模块化多种规范在ts中的实现

ts中使用es6 module，commonjs，AMD等都是可以的。（import/require）而UMD库（既可以通过\<script\> 标签引入，又可以通过 import 导入的库，称为 UMD 库。）**相比于 npm 包**的类型声明文件，我们需要额外声明一个全局变量，为了实现这种方式，ts 提供了一个新语法 ```export as namespace```。

### 导入模块一些需要扩展的情况

还有一种可能的情况是我们在导入了第三方库之后，第三方库中扩展了一个全局变量，但此时**全局变量**的类型并没有对应扩展，这样在编译的时候就会进行报错，利用声明合并或者```declare namespace```可以进行对应的类型扩展。而针对于**npm包/UMD库**需要用```declare global```这种特定语法来进行全局变量的类型扩展，并且必须有export导出（如果不导出东西就写一个空对象），因为有export才会把这个识别成一个模块而非全局变量声明文件。

同理的，导入模块时模块也有可能改变了原有的一些结构，因此我们也需要针对这个模块进行扩展，与上面类似的，导入模块之后使用```declare module```来进行扩展。

### 声明文件引入模块

有时我们的声明文件需要引入别的文件已有的一些类型，如果使用import的方法进行引入，这个声明文件会被识别为一个npm包/UMD库，又或者我们需要引用声明文件中的类型时，（因为声明文件中没有export）因此为了避开这两个问题，ts中引入了**三斜线指令（///）**，这个指令实际上就与import是一样的，这个指令一般只在这两个情况下使用，其他情况还是使用import。并且注意语法：**三斜线指令必须放在文件的最顶端，三斜线指令的前面只允许出现单行或多行注释**。

### 自动生成声明文件

通过配置tsconfig.json或者在tsc编译时加上declaration参数，编译时就会自动加上对应的.d.ts文件。发布时也有两种方式，一个是只发布声明文件，发布到@types上；二是连着源码一起发布，只要在package.json里制定好type参数即可。

## 参考链接

[ts中文入门教程](https://ts.xcatliu.com/)[ts官方文档](https://www.typescriptlang.org/docs/handbook/basic-types.html)
